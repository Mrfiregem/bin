#!/usr/bin/env python
__version__ = "0.2.0"
import argparse
import os
import subprocess
import sys
import tempfile
from shutil import which

# Parse commandline arguments
parser = argparse.ArgumentParser(
    prog="piper",
    description="Write a file with your editor, and pass it to a program.",
    epilog="Use '--' to prevent program flags to the right of it being parsed by piper.",
)
parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=f"%(prog)s {__version__}",
)
parser.add_argument(
    "-V", "--verbose", action="store_true", help="show log messages using stderr"
)
parser.add_argument(
    "-t",
    "--type",
    type=str,
    choices=["stdin", "s", "argument", "a", "expand", "x"],
    metavar="TYPE",
    default="stdin",
    help="how the file will be given to the program",
)
parser.add_argument("program", help="the program to pass your file into")
parser.add_argument(
    "prog_args",
    metavar="args",
    nargs="*",
    default=[],
    help="Arguments to pass to the program",
)
args = parser.parse_args()


def verbose_msg(msg):
    if args.verbose:
        sys.stderr.write(f"{parser.prog}: info: {msg}\n")


# Make sure program user specifies exists
program = which(args.program)
if program is None:
    sys.stderr.write(f"{parser.prog}: error: program not in path: {args.program}\n")
    exit(1)

# Set text editor based on $VISUAL -> $EDITOR -> vim
if "VISUAL" in os.environ:
    editor_name = os.getenv("VISUAL")
else:
    editor_name = os.getenv("EDITOR", "vim")
editor = which(editor_name)

if editor is None:
    sys.stderr.write(f"{parser.prog}: error: editor not in path: {editor_name}\n")
    exit(1)
verbose_msg(f"found program: {program}\n")


# Create a temporary file and allow user to edit it
with tempfile.NamedTemporaryFile(suffix=".piper.tmp") as tmp:
    tmp.flush()  # Ensure data is written to the file

    # Open editor and store exitcode
    editor_exit = subprocess.call([editor, tmp.name])
    if editor_exit != 0:
        sys.stderr.write(
            f"{parser.prog}: error: {program} exited with code {editor_exit}\n"
        )
        exit(editor_exit)

    # Store file content as list of lines
    file_contents = tmp.readlines()
    if file_contents[0].strip() == b"piper:exit":
        verbose_msg(f"found exit directive: exiting program")
        tmp.close()
        exit(0)

    # Replace argument with file name in program arguments
    if r"{piper:filename}" in args.prog_args:
        pass_args = [
            tmp.name if s == r"{piper:filename}" else s for s in args.prog_args
        ]
    else:
        pass_args = args.prog_args
    verbose_msg(f"{pass_args=}")

    if args.type in ["stdin", "s"]:
        proc = subprocess.Popen([program] + pass_args, stdin=tmp)
    elif args.type in ["argument", "a"]:
        if r"{piper:filename}" in args.prog_args:
            final_args = [program] + pass_args
            verbose_msg(f"{final_args=}")
            proc = subprocess.Popen(final_args)
        else:
            final_args = [program] + pass_args + [tmp.name]
            verbose_msg(f"{final_args=}")
            proc = subprocess.Popen(final_args)
    elif args.type in ["expand", "x"]:
        stripped_lines = [line.strip() for line in file_contents if line]
        final_args = [program] + pass_args + stripped_lines
        verbose_msg(f"{final_args=}")
        proc = subprocess.Popen(final_args)

    proc.wait()
    tmp.close()
