#!/usr/bin/env python
__version__ = "0.1.0"
import argparse
import os
import subprocess
import sys
import tempfile
from shutil import which

# Parse commandline arguments
parser = argparse.ArgumentParser(
    prog="piper",
    description="Write a file with your editor, and pass it to a program.",
    epilog="Use '--' to prevent program flags to the right of it being parsed by piper.",
)
parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=f"%(prog)s {__version__}",
)
parser.add_argument(
    "-V", "--verbose", action="store_true", help="show log messages using stderr"
)
parser.add_argument(
    "-t",
    "--type",
    type=str,
    choices=["stdin", "s", "argument", "a", "expand", "x"],
    metavar="TYPE",
    default="stdin",
    help="how the file will be given to the program",
)
parser.add_argument("program", help="the program to pass your file into")
parser.add_argument(
    "prog_args",
    metavar="args",
    nargs="*",
    default=[],
    help="Arguments to pass to the program",
)
args = parser.parse_args()

# Make sure program user specifies exists
program = which(args.program)
if program is None:
    sys.stderr.write(f"{parser.prog}: error: program not in path: {args.program}\n")
    exit(1)

# Set text editor based on $VISUAL -> $EDITOR -> vim
if "VISUAL" in os.environ:
    editor_name = os.getenv("VISUAL")
else:
    editor_name = os.getenv("EDITOR", "vim")
editor = which(editor_name)

if editor is None:
    sys.stderr.write(f"{parser.prog}: error: editor not in path: {editor_name}\n")
    exit(1)
elif args.verbose:
    sys.stderr.write(f"{parser.prog}: info: found program: {program}\n")


# Create a temporary file and allow user to edit it
with tempfile.NamedTemporaryFile(suffix=".piper.tmp") as tmp:
    tmp.flush()  # Ensure data is written to the file
    editor_exit = subprocess.call([editor, tmp.name])
    if editor_exit != 0:
        sys.stderr.write(
            f"{parser.prog}: error: {program} exited with code {editor_exit}\n"
        )
        exit(editor_exit)
    elif tmp.readline().strip() == b"piper:exit":
        print(f"{parser.prog}: info: found exit directive: exiting program")
        tmp.close()
        exit(0)

    # Replace argument with file name in program arguments
    if r"{piper:filename}" in args.prog_args:
        pass_args = [
            tmp.name if s == r"{piper:filename}" else s for s in args.prog_args
        ]
    else:
        pass_args = args.prog_args

    if args.type in ["stdin", "s"]:
        proc = subprocess.Popen([program] + pass_args, stdin=tmp)
    elif args.type in ["argument", "a"]:
        if r"{piper:filename}" in args.prog_args:
            proc = subprocess.Popen([program] + pass_args)
        else:
            proc = subprocess.Popen([program] + pass_args + [tmp.name])
    elif args.type in ["expand", "x"]:
        proc = subprocess.Popen(
            [program] + pass_args + [line.strip() for line in tmp.readlines() if line]
        )

    proc.wait()
    tmp.close()
