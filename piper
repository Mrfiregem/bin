#!/usr/bin/env python
__version__ = "0.2.2"
import argparse
import os
import subprocess
import sys
import tempfile
from shutil import which

help_msg = """\
Tip: Use '--' after any piper flags to pass subsequent flags to your
program correctly.

'--type' can take one of three arguments:
    - stdin / s:    Pass the file to the program's stdin. (default)
    - argument / a: Pass the filename as the last arg
                    to the program, or replace the
                    string '{piper:filename}' with it.
    - expand / x:   Append each line of the file as an
                    argument to the program after.

Piper will quit without running the program if your editor exits with
a non-zero error code (e.g. with vim's :cquit). If your editor does
not support this, you can also accomplish the same thing by writing
'piper:exit' as the first line of text in the file."""

# Parse commandline arguments
parser = argparse.ArgumentParser(
    prog="piper",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description="Write a file with your editor, and pass it to a program.",
    epilog=help_msg,
)
parser.add_argument(
    "-v",
    "--version",
    action="version",
    version=f"%(prog)s {__version__}",
)
parser.add_argument(
    "-V", "--verbose", action="store_true", help="show log messages using stderr"
)
parser.add_argument(
    "-t",
    "--type",
    type=str,
    choices=["stdin", "s", "argument", "a", "expand", "x"],
    metavar="TYPE",
    default="stdin",
    help="how the file will be given to the program",
)
parser.add_argument("program", help="the program to pass your file into")
parser.add_argument(
    "prog_args",
    metavar="args",
    nargs="*",
    default=[],
    help="Arguments to pass to the program",
)
args = parser.parse_args()


def verbose_msg(msg):
    if args.verbose:
        sys.stderr.write(f"{parser.prog}: info: {msg}\n")


# Make sure program user specifies exists
program = which(args.program)
if program is None:
    sys.stderr.write(f"{parser.prog}: error: program not in path: {args.program}\n")
    exit(1)

# Set text editor based on $VISUAL -> $EDITOR -> vim
if "VISUAL" in os.environ:
    editor_name = os.getenv("VISUAL")
else:
    editor_name = os.getenv("EDITOR", "vim")
editor = which(editor_name)  # type: ignore[type-var]

if editor is None:
    sys.stderr.write(f"{parser.prog}: error: editor not in path: {editor_name}\n")
    exit(1)
verbose_msg(f"found program: {program}\n")


# Create a temporary file and allow user to edit it
with tempfile.NamedTemporaryFile(suffix=".piper.tmp") as tmp:
    tmp.flush()  # Ensure data is written to the file

    # Open editor and store exitcode
    editor_exit = subprocess.call([editor, tmp.name])
    if editor_exit != 0:
        sys.stderr.write(
            f"{parser.prog}: error: {program} exited with code {editor_exit}\n"
        )
        exit(editor_exit)
    verbose_msg(f"File saved to {tmp.name}")

    # Store file content as list of lines
    file_contents = tmp.readlines()
    if file_contents[0].strip() == b"piper:exit":
        verbose_msg("found exit directive: exiting program")
        tmp.close()
        exit(0)

    # Replace argument with file name in program arguments
    if r"{piper:filename}" in args.prog_args:
        pass_args = [
            tmp.name if s == r"{piper:filename}" else s for s in args.prog_args
        ]
    else:
        pass_args = args.prog_args
    verbose_msg(f"{pass_args=}")

    if args.type in ["stdin", "s"]:
        verbose_msg(f"Passing contents of file to {program}")
        subprocess.run([program] + pass_args, input=b"".join(file_contents))
    elif args.type in ["argument", "a"]:
        if r"{piper:filename}" in args.prog_args:
            final_args = [program] + pass_args
            verbose_msg(f"{final_args=}")
            proc = subprocess.Popen(final_args)
        else:
            final_args = [program] + pass_args + [tmp.name]
            verbose_msg(f"{final_args=}")
            proc = subprocess.Popen(final_args)
        proc.wait()
    elif args.type in ["expand", "x"]:
        stripped_lines = [line.strip() for line in file_contents if line]
        final_args = [program] + pass_args + stripped_lines
        verbose_msg(f"{final_args=}")
        proc = subprocess.Popen(final_args)
        proc.wait()

    tmp.close()
